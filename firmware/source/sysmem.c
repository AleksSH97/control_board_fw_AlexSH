/**
 ******************************************************************************
 * @file      sysmem.c
 * @author    Auto-generated by STM32CubeIDE
 * @brief     STM32CubeIDE System Memory calls file
 * @revision  1
 *
 *            For more information about which C functions
 *            need which of these lowlevel functions
 *            please consult the Newlib libc-manual
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

/**
 * Defining the symbol __NEWLIB_SAFE_FROM_INTERRUPT__ will protect
 * newlib malloc and related functions from interrupts.
 * Please note that this disables interrupts during malloc and related functions
 * which might interfere with interrupt real-time performance.
 */
#define __NEWLIB_SAFE_FROM_INTERRUPT__

/* Includes */
#include <errno.h>
#include <stdint.h>
#include <cmsis_compiler.h>
#include <sys/reent.h>
#include "FreeRTOS.h"
//#include "main.h"

#define RTOS_SUSPEND_ALL_TASKS vTaskSuspendAll
#define RTOS_RESUME_ALL_TASKS  xTaskResumeAll

/* Variables */
extern int errno;

/* Recursive critical section implementation */
typedef struct
{
  uint8_t flag;
  uint8_t counter;
} CriticalSection_TypeDef;

/**
 * __critical_section_init
 * Initialize recursive lock
 */
static void inline __critical_section_init(CriticalSection_TypeDef *cs)
{
  cs->flag = 0;
  cs->counter = 0;
}

/**
 * __critical_section_enter
 * Take recursive lock
 */
static void inline __critical_section_enter(CriticalSection_TypeDef *cs)
{
  uint8_t flag = (uint8_t)(__get_PRIMASK() & 0x1); /* PRIMASK.PM */
  __disable_irq();
  if (0 == cs->counter)
  {
    cs->flag = flag;
  }
  cs->counter++;
}

/**
 * __critical_section_leave
 * Release recursive lock
 */
static void inline __critical_section_leave(CriticalSection_TypeDef *cs)
{
  cs->counter--;
  if (0 == cs->counter && !cs->flag)
  {
    __enable_irq();
  }
}

#ifdef __NEWLIB_SAFE_FROM_INTERRUPT__
static CriticalSection_TypeDef critical_section_malloc = {0, 0};
static CriticalSection_TypeDef critical_section_env = {0, 0};
#else
/* Note: The application will end up in an endless loop if calling malloc or related functions from interrupt */
#warning The application will end up in an endless loop if calling malloc or related functions from interrupt
#if !defined(RTOS_SUSPEND_ALL_TASKS) || !defined(RTOS_RESUME_ALL_TASKS)
/* If you are not using a RTOS, you can remove the #error below */
#error RTOS_SUSPEND_ALL_TASKS and RTOS_RESUME_ALL_TASKS needs to be defined in main.h
#endif /* !defined(RTOS_SUSPEND_ALL_TASKS) || !defined(RTOS_RESUME_ALL_TASKS) */
#endif /* __NEWLIB_SAFE_FROM_INTERRUPT__ */

/**
 * __malloc_lock
 * Called by malloc and related functions in the C library, recursive lock is required
 */
#if __STD_C
void __malloc_lock(struct _reent *reent)
#else
void __malloc_lock()
#endif /* __STD_C */
{
#ifdef __NEWLIB_SAFE_FROM_INTERRUPT__
  __critical_section_enter(&critical_section_malloc);
#else
  if (__get_IPSR())
  {
    /* Not using thread-safe newlib and malloc is called from an interrupt */
    /* Either don't use malloc from an interrupt or define __NEWLIB_SAFE_FROM_INTERRUPT__ */
    while (1);
  }

#ifdef RTOS_SUSPEND_ALL_TASKS
  RTOS_SUSPEND_ALL_TASKS();
#endif /* RTOS_SUSPEND_ALL_TASKS */
#endif /* __NEWLIB_SAFE_FROM_INTERRUPT__ */
}


/**
 * __malloc_unlock
 * Called by malloc and related functions in the C library, recursive lock is required
 */
#if __STD_C
void __malloc_unlock(struct _reent *reent)
#else
void __malloc_unlock()
#endif /* __STD_C */
{
#ifdef __NEWLIB_SAFE_FROM_INTERRUPT__
  __critical_section_leave(&critical_section_malloc);
#else
#ifdef RTOS_RESUME_ALL_TASKS
  RTOS_RESUME_ALL_TASKS();
#endif /* RTOS_RESUME_ALL_TASKS */
#endif /* __NEWLIB_SAFE_FROM_INTERRUPT__ */
}

/**
 * __env_lock
 * Called by the different env functions in the C library
 */
void __env_lock(struct _reent *reent)
{
#ifdef __NEWLIB_SAFE_FROM_INTERRUPT__
  __critical_section_enter(&critical_section_env);
#else
  if (__get_IPSR())
  {
    /* Not using thread-safe newlib and the environment is accessed from an interrupt */
    /* Either don't access the environment from an interrupt or define __NEWLIB_SAFE_FROM_INTERRUPT__ */
    while (1);
  }

#ifdef RTOS_SUSPEND_ALL_TASKS
  RTOS_SUSPEND_ALL_TASKS();
#endif /* RTOS_SUSPEND_ALL_TASKS */
#endif /* __NEWLIB_SAFE_FROM_INTERRUPT__ */
}

/**
 * __env_unlock
 * Called by the different env functions in the C library
 */
void __env_unlock(struct _reent *reent)
{
#ifdef __NEWLIB_SAFE_FROM_INTERRUPT__
  __critical_section_leave(&critical_section_env);
#else
#ifdef RTOS_RESUME_ALL_TASKS
  RTOS_RESUME_ALL_TASKS();
#endif /* RTOS_RESUME_ALL_TASKS */
#endif /* __NEWLIB_SAFE_FROM_INTERRUPT__ */
}

/**
 * _sbrk
 * Increase program data space. Malloc and related functions depend on this
 */
void *_sbrk(ptrdiff_t incr)
{
  extern uint8_t end; /* end symbol defined in the linker script */
  extern uint8_t _estack; /* _estack symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* _Min_Stack_Size symbol defined in the linker script */
  const uint8_t *max_heap = (uint8_t *)((uint32_t)&_estack - (uint32_t)&_Min_Stack_Size);
  static uint8_t *heap_end = NULL;
  uint8_t *prev_heap_end;

  if (NULL == heap_end)
  {
    heap_end = &end;
  }

  prev_heap_end = heap_end;
  if (heap_end + incr > max_heap)
  {
    errno = ENOMEM;
    return (void *)-1;
  }

  heap_end += incr;

  return (void *)prev_heap_end;
}
